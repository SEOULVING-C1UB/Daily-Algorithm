'''
컨셉
1) 화덕의 크기 만큼 피자를 담을 Q 배열을 선언합니다.
    1-1) 이 떄, 구해야 하는 것이 '몇 번째 피자'에 대한 정보 이므로
    1-2) 피자가 들어가고 나올 때 마다,
    1-3) 피자의 순서 정보도 함께 반영되도록 평행한 리스트를 만들어 둡니다.
2) while 문을 사용해서 피자 치즈의 수가 녹는 것을 표현합니다.
    2-1) 가장 먼저 들어온 피자의 치즈가 항상 가장 먼저 녹습니다.
    2-2) pop(0)를 통해 꺼낸 피자에 (//2)를 사용하여 치즈를 녹입니다.
    2-3) 그리고 나서 append를 통해 녹은 치즈가 반영된 피자를 넣어줍니다.
    2-4) 이 과정을 반복할 떄 평행하도록 순서 정보를 보존하는 Q리스트도 똑같이 작업합니다.
3) 만약 melt 가 0이 되는 경우 새로운 피자를 삽입합니다.
    3-1) 기존의 C 배열에서 pop을 해주며, 이 때는 빈 리스트가 아닌지 체크해야 합니다.
    3-2) C에서 피자가 없어지는 것이 화덕에 있는 피자들의 치즈가 녹는 것 보다 빠르기 때문입니다.
    3-3) pop으로 꺼내기 때문에 기존의 피자들에 대한 인덱스 정보를 잘 기억하고 있어야 합니다.
    3-4) C에서 꺼내어 넣으면서 직전의 index 값에 += 1을 해줍니다.
    3-5) 만약, 화덕에서 melt 가 0이라서 새로운 피자를 꺼내야 하는 데 비어 있는 경우
    3-6) continue를 사용하여 그 상태로 pop과 append를 할 수 있도록 조건문을 제어합니다.
4) 화덕의 피자가 1개 남아있을 떄 까지 위 과정을 반복합니다.
    4-1) 그래야 Q에 남아있는 피자와 그에 대한 순서가 1개 존재하기 때문입니다.
    4-2) 순서를 꺼내어 출력할 떄
    4-3) 피자의 순서가 1부터 시작하므로 +1로 보정해줍니다.
'''


import sys
sys.stdin = open('(5099)_input.txt')

T = int(input())

for t in range(1,T+1):
    N, M = map(int,input().split())
    C = list(map(int,input().split()))

    Q1 = []                 # 피자의 치즈 개수를 담을 큐
    Q2 = []                 # 피자의 순서를 담을 큐
    for i in range(N):
        Q1.append(C.pop(0)) # C에서 부터 Q1에 피자를 화덕의 크기 N만큼
        Q2.append(i)        # 인덱스 정보 i를 Q2에 삽입

    while len(Q1) != 1:     # 구해야 하는 값은 화덕에 남은 피자 1개
        melt = Q1.pop(0)
        melt //= 2
        idx = Q2.pop(0)
        if melt == 0:       # 만약 melt가 다 녹으면 새로운 피자를 가져와야 합니다.
            if len(C) != 0: # 그런데 이미 새로운 피자가 없을 수도 있습니다.
                melt = C.pop(0)
                i += 1          # 위에서 기억한 i부터 시작하여 1씩 증가
                Q1.append(melt)
                Q2.append(i)
            else:
                continue    # 만약 새로운 피자가 없으면 화덕 내에서 계속 enQ, pop을 반복해야 합니다
        else:
            Q1.append(melt)
            Q2.append(idx)

    print('#{} {}'.format(t,Q2[0] + 1)) # 피자 순서를 보존하기 위한 +1